// Generated by ReScript, PLEASE EDIT WITH CARE

import Stripe from "stripe";
import * as Js_dict from "rescript/lib/es6/Js_dict.js";
import * as Js_option from "rescript/lib/es6/Js_option.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Stdlib_Exn from "rescript/lib/es6/Stdlib_Exn.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as S$RescriptSchema from "rescript-schema/src/S.res.mjs";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

function $$catch(promise, callback) {
  return promise.catch(err => callback(Primitive_exceptions.internalToException(err)));
}

let $$Promise = {
  $$catch: $$catch
};

let unsafeDeleteKey = (function (dict,key) {
      delete dict[key];
    });

let Dict = {
  unsafeDeleteKey: unsafeDeleteKey
};

function last(array) {
  return array[array.length - 1 | 0];
}

let $$Array = {
  last: last
};

function addMany(set, values) {
  values.forEach(value => {
    set.add(value);
  });
}

let $$Set = {
  addMany: addMany
};

let Stdlib = {
  $$Promise: $$Promise,
  Dict: Dict,
  $$Array: $$Array,
  $$Set: $$Set
};

function make(prim) {
  return new Stripe(prim, {"telemetry": false});
}

let Meter = {};

let MeterEvent = {};

let Price = {};

let Product = {};

async function syncProduct(stripe, productConfig, meters, usedCustomerMeters, interval) {
  console.log("Searching for active product \"" + productConfig.ref + "\"...");
  let match = await stripe.products.search({
    query: "active:\"true\" AND metadata[\"#product_ref\"]:\"" + productConfig.ref + "\"",
    limit: 2
  });
  let match$1 = match.data;
  let len = match$1.length;
  let product;
  if (len !== 1) {
    if (len !== 0) {
      product = Stdlib_Exn.raiseError("There are multiple active products \"" + productConfig.ref + "\". Please go to dashboard and delete not needed ones (https://dashboard.stripe.com/test/products?active=true)");
    } else {
      console.log("No active product \"" + productConfig.ref + "\" found. Creating a new one...");
      let p = await stripe.products.create({
        name: productConfig.name,
        metadata: Js_dict.fromArray([[
            "#product_ref",
            productConfig.ref
          ]]),
        unit_label: productConfig.unitLabel
      });
      console.log("Product \"" + productConfig.ref + "\" successfully created. Product ID: " + p.id);
      product = p;
    }
  } else {
    let p$1 = match$1[0];
    console.log("Found an existing product \"" + productConfig.ref + "\". Product ID: " + p$1.id);
    let fieldsToSync = {};
    let match$2 = p$1.unit_label;
    let match$3 = productConfig.unitLabel;
    let exit = 0;
    if (match$2 === null) {
      if (match$3 !== undefined) {
        exit = 1;
      }
      
    } else if (match$3 === undefined || match$2 !== match$3) {
      exit = 1;
    }
    if (exit === 1) {
      if (match$3 !== undefined) {
        fieldsToSync.unit_label = match$3;
      } else {
        fieldsToSync.unit_label = "";
      }
    }
    let fieldNamesToSync = Object.keys(fieldsToSync);
    if (fieldNamesToSync.length > 0) {
      console.log("Syncing product \"" + productConfig.ref + "\" fields " + fieldNamesToSync.join(", ") + "...");
      let p$2 = await stripe.products.update(p$1.id, fieldsToSync);
      console.log("Product \"" + productConfig.ref + "\" fields successfully updated");
      product = p$2;
    } else {
      console.log("Product \"" + productConfig.ref + "\" is in sync");
      product = p$1;
    }
  }
  console.log("Searching for product \"" + productConfig.ref + "\" active prices...");
  let prices = await stripe.prices.list({
    active: true,
    product: product.id
  });
  console.log("Found " + prices.data.length.toString() + " product \"" + productConfig.ref + "\" active prices");
  if (prices.has_more) {
    Stdlib_Exn.raiseError("The pagination on prices is not supported yet. Product \"" + productConfig.ref + "\" has to many active prices");
  }
  let createPriceFromConfig = async priceConfig => {
    let match = priceConfig.recurring;
    let match$1;
    if (match.TAG === "Metered") {
      let ref = match.ref;
      let meters$1 = meters !== undefined ? meters : Stdlib_Exn.raiseError("The \"meters\" argument is required when product catalog contains a Metered price");
      let usedCustomerMeters$1 = usedCustomerMeters !== undefined ? Primitive_option.valFromOption(usedCustomerMeters) : Stdlib_Exn.raiseError("The \"usedCustomerMeters\" argument is required when product catalog contains a Metered price");
      let getEventName = (meterRef, _counterOpt) => {
        while (true) {
          let counterOpt = _counterOpt;
          let counter = counterOpt !== undefined ? counterOpt : 0;
          let eventName = counter !== 0 ? meterRef + "_" + (counter + 1 | 0).toString() : meterRef;
          if (!usedCustomerMeters$1.has(eventName)) {
            return eventName;
          }
          _counterOpt = counter + 1 | 0;
          continue;
        };
      };
      let eventName = getEventName(ref, undefined);
      let meter = Js_dict.get(meters$1, eventName);
      let meter$1;
      if (meter !== undefined) {
        meter$1 = meter;
      } else {
        console.log("Meter \"" + eventName + "\" does not exist. Creating...");
        let meter$2 = await stripe.billing.meters.create({
          default_aggregation: {
            formula: "sum"
          },
          display_name: ref,
          event_name: eventName
        });
        console.log("Meter \"" + eventName + "\" successfully created. Meter ID: " + meter$2.id);
        meter$1 = meter$2;
      }
      match$1 = [
        Js_dict.fromArray([
          [
            "#meter_ref",
            ref
          ],
          [
            "#meter_event_name",
            eventName
          ],
          [
            "#price_ref",
            priceConfig.ref
          ]
        ]),
        {
          interval: match.interval,
          meter: meter$1.id,
          usage_type: "metered"
        },
        ref === eventName,
        ref === eventName ? undefined : "Copy with meter \"" + eventName + "\""
      ];
    } else {
      match$1 = [
        undefined,
        {
          interval: match.interval
        },
        true,
        undefined
      ];
    }
    let transferLookupKey = match$1[2];
    let match$2 = priceConfig.lookupKey;
    return await stripe.prices.create({
      currency: priceConfig.currency,
      product: product.id,
      metadata: match$1[0],
      nickname: match$1[3],
      recurring: match$1[1],
      unit_amount: priceConfig.unitAmountInCents,
      lookup_key: transferLookupKey && match$2 !== undefined && match$2 ? priceConfig.ref : undefined,
      transfer_lookup_key: transferLookupKey
    });
  };
  let prices$1 = await Promise.all(productConfig.prices.filter(priceConfig => {
    let match = priceConfig.recurring;
    if (interval !== undefined) {
      return match.interval === interval;
    } else {
      return true;
    }
  }).map(async priceConfig => {
    let existingPrice = prices.data.find(price => {
      let tmp = false;
      if (priceConfig.currency === price.currency) {
        let match = priceConfig.lookupKey;
        let match$1 = price.lookup_key;
        let tmp$1;
        let exit = 0;
        if (match !== undefined && match) {
          tmp$1 = match$1 === null ? false : priceConfig.ref === match$1;
        } else {
          exit = 1;
        }
        if (exit === 1) {
          tmp$1 = match$1 === null;
        }
        tmp = tmp$1;
      }
      if (!(tmp && priceConfig.unitAmountInCents === price.unit_amount)) {
        return false;
      }
      let priceRecurring = price.recurring;
      if (priceRecurring === null) {
        return false;
      }
      let match$2 = priceConfig.recurring;
      if (match$2.TAG !== "Metered") {
        if (priceRecurring.usage_type === "licensed" && priceRecurring.interval === match$2.interval) {
          return priceRecurring.meter === null;
        } else {
          return false;
        }
      }
      let usedCustomerMeters$1 = usedCustomerMeters !== undefined ? Primitive_option.valFromOption(usedCustomerMeters) : Stdlib_Exn.raiseError("The \"usedCustomerMeters\" argument is required when product catalog contains a Metered price");
      if (!(priceRecurring.usage_type === "metered" && priceRecurring.interval === match$2.interval && Js_option.isSome(Primitive_option.fromNull(priceRecurring.meter)) && price.metadata["#meter_ref"] === match$2.ref)) {
        return false;
      }
      let meterEventName = Js_dict.get(price.metadata, "#meter_event_name");
      if (meterEventName !== undefined) {
        return !usedCustomerMeters$1.has(meterEventName);
      } else {
        return false;
      }
    });
    if (existingPrice !== undefined) {
      console.log("Found an existing price \"" + priceConfig.ref + "\" for product \"" + productConfig.ref + "\". Price ID: " + existingPrice.id);
      return existingPrice;
    }
    console.log("Price \"" + priceConfig.ref + "\" for product \"" + productConfig.ref + "\" is not in sync. Updating...");
    let price = await createPriceFromConfig(priceConfig);
    console.log("Price \"" + priceConfig.ref + "\" for product \"" + productConfig.ref + "\" successfully recreated with the new values. Price ID: " + price.id);
    return price;
  }));
  return {
    product: product,
    prices: prices$1
  };
}

async function sync(stripe, productCatalog, usedCustomerMeters, interval) {
  let isMeterNeeded = productCatalog.products.some(p => p.prices.some(p => {
    let match = p.recurring;
    return match.TAG === "Metered";
  }));
  let meters;
  if (isMeterNeeded) {
    console.log("Loading active meters...");
    let match = await stripe.billing.meters.list({
      status: "active",
      limit: 100
    });
    let meters$1 = match.data;
    console.log("Loaded " + meters$1.length.toString() + " active meters");
    meters = Js_dict.fromArray(meters$1.map(meter => [
      meter.event_name,
      meter
    ]));
  } else {
    meters = undefined;
  }
  let products = await Promise.all(productCatalog.products.map(p => syncProduct(stripe, p, meters, usedCustomerMeters, interval)));
  console.log("Successfully finished syncing products");
  return products;
}

let ProductCatalog = {
  syncProduct: syncProduct,
  sync: sync
};

let cache = {
  hasMore: true,
  lock: 0,
  items: []
};

async function findByMetadata(stripe, metadata) {
  let lock = cache.lock + 1 | 0;
  cache.lock = lock;
  let entries = Js_dict.entries(metadata);
  let len = entries.length;
  let matches;
  if (len !== 1) {
    matches = len !== 0 ? item => entries.every(param => item.metadata[param[0]] === param[1]) : param => true;
  } else {
    let match = entries[0];
    let value = match[1];
    let key = match[0];
    matches = item => item.metadata[key] === value;
  }
  let updateCache = (data, hasMore, isCatchUp) => {
    if (cache.lock !== lock) {
      return;
    }
    if (isCatchUp) {
      let newCacheItems = data.map(item => ({
        id: item.id,
        metadata: item.metadata
      }));
      cache.items = newCacheItems.concat(cache.items);
      return;
    }
    cache.hasMore = hasMore;
    data.forEach(item => {
      cache.items.push({
        id: item.id,
        metadata: item.metadata
      });
    });
  };
  let lookup = async startingAfter => {
    let page = await stripe.customers.list({
      starting_after: startingAfter,
      limit: 1000
    });
    updateCache(page.data, page.has_more, false);
    let match = page.data.find(matches);
    if (match !== undefined) {
      if (match === undefined) {
        return;
      } else {
        return Primitive_option.some(match);
      }
    } else if (page.has_more) {
      return await lookup(last(page.data).id);
    } else {
      return;
    }
  };
  let catchUpToCache = async endingBefore => {
    let data = await stripe.customers.list({
      ending_before: endingBefore,
      limit: 100
    }).autoPagingToArray({
      limit: 10000
    });
    if (data.length === 10000) {
      Stdlib_Exn.raiseError("Too many new customers to cache.");
    }
    updateCache(data, false, true);
    return Primitive_option.fromUndefined(data.find(matches));
  };
  let items = cache.items;
  if (items.length !== 0) {
    console.log("Searching for customer by metadata in cache", metadata);
    let item = cache.items.find(matches);
    if (item !== undefined) {
      console.log("Successfully found Customer ID \"" + item.id + "\" by metadata in cache. Retrieving data...", metadata);
      let customer = await stripe.customers.retrieve(item.id);
      let isValid = customer.deleted ? false : matches(customer);
      console.log("Customer ID \"" + item.id + "\" " + (
        customer.deleted ? "is deleted" : (
            isValid ? "matches metadata lookup. Returning!" : "doesn't match cached metadata"
          )
      ), metadata);
      if (isValid) {
        return customer;
      }
      let indexInCache = cache.items.findIndex(item => item.id === customer.id);
      if (indexInCache !== -1) {
        if (customer.deleted) {
          cache.items.splice(indexInCache, 1);
        } else {
          cache.items[indexInCache] = {
            id: customer.id,
            metadata: customer.metadata
          };
        }
      }
      return;
    }
    console.log("Customer by metadata isn't found in cache. Requesting newly created customers...", metadata);
    let match$1 = await catchUpToCache(items[0].id);
    if (match$1 !== undefined) {
      console.log("Successfully found customer \"" + match$1.id + "\" by metadata", metadata);
      return match$1;
    }
    if (cache.hasMore) {
      console.log("Any new customer doesn't match metadata. Looking for older customers on server...", metadata);
      let c = await lookup(last(cache.items).id);
      console.log("Finished looking for customers by metadata", metadata);
      return c;
    }
    console.log("Customer by metadata isn't found", metadata);
    return;
  }
  console.log("Customer metadata lookup cache is empty. Looking for customers on server...", metadata);
  let c$1 = await lookup(undefined);
  console.log("Finished looking for customers by metadata", metadata);
  return c$1;
}

let Customer = {
  findByMetadata: findByMetadata
};

function isTerminatedStatus(status) {
  return false;
}

function getMeterId(subscription, meterRef) {
  return Belt_Option.flatMap(Belt_Option.flatMap(Primitive_option.fromUndefined(subscription.items.data.find(item => item.price.metadata["#meter_ref"] === meterRef)), i => Primitive_option.fromNull(i.price.recurring)), r => Primitive_option.fromNull(r.meter));
}

function getMeterEventName(subscription, meterRef) {
  return Belt_Option.flatMap(Primitive_option.fromUndefined(subscription.items.data.find(item => item.price.metadata["#meter_ref"] === meterRef)), i => Js_dict.get(i.price.metadata, "#meter_event_name"));
}

async function reportMeterUsage(stripe, subscription, meterRef, value, timestamp, identifier) {
  let meterEventName = getMeterEventName(subscription, meterRef);
  if (meterEventName !== undefined) {
    await stripe.billing.meterEvents.create({
      event_name: meterEventName,
      payload: Js_dict.fromArray([
        [
          "value",
          value.toString()
        ],
        [
          "stripe_customer_id",
          subscription.customer
        ]
      ]),
      identifier: identifier,
      timestamp: timestamp
    });
    return {
      TAG: "Ok",
      _0: undefined
    };
  } else {
    return {
      TAG: "Error",
      _0: "MeterNotFound"
    };
  }
}

let Subscription = {
  isTerminatedStatus: isTerminatedStatus,
  getMeterId: getMeterId,
  getMeterEventName: getMeterEventName,
  reportMeterUsage: reportMeterUsage
};

function prefillEmail(link, email) {
  if (email !== undefined) {
    return link + "?prefilled_email=" + encodeURIComponent(email);
  } else {
    return link;
  }
}

let CustomerPortal = {
  prefillEmail: prefillEmail
};

let Session = {};

let Checkout = {
  Session: Session
};

function constructEvent(stripe, body, sig, secret) {
  try {
    let event = stripe.webhooks.constructEvent(body, sig, secret);
    let match = event.type;
    let tmp;
    switch (match) {
      case "customer.subscription.created" :
        tmp = {
          TAG: "CustomerSubscriptionCreated",
          _0: event
        };
        break;
      case "customer.subscription.deleted" :
        tmp = {
          TAG: "CustomerSubscriptionDeleted",
          _0: event
        };
        break;
      case "customer.subscription.updated" :
        tmp = {
          TAG: "CustomerSubscriptionUpdated",
          _0: event
        };
        break;
      default:
        tmp = {
          TAG: "Unknown",
          _0: event
        };
    }
    return {
      TAG: "Ok",
      _0: tmp
    };
  } catch (raw_err) {
    let err = Primitive_exceptions.internalToException(raw_err);
    if (err.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return {
        TAG: "Error",
        _0: err._1.message
      };
    }
    throw err;
  }
}

let Webhook = {
  constructEvent: constructEvent
};

let Plan = {};

let refField = "#subscription_ref";

let planField = "#subscription_plan";

async function listSubscriptions(stripe, config, customerId) {
  let match = await stripe.subscriptions.list({
    customer: customerId,
    limit: 100
  });
  if (match.has_more) {
    return Stdlib_Exn.raiseError("Found more than 100 subscriptions, which is not supported yet");
  } else {
    return match.data.filter(subscription => subscription.metadata[refField] === config.ref);
  }
}

function processData(data, config) {
  let primaryFields = [refField];
  let customerLookupFields = [];
  let metadataFields = [refField];
  let schema = S$RescriptSchema.object(s => {
    s.tag(refField, config.ref);
    return config.data({
      primary: (param, $staropt$star) => {
        let fieldName = param.fieldName;
        let customerLookup = $staropt$star !== undefined ? $staropt$star : false;
        primaryFields.push(fieldName);
        metadataFields.push(fieldName);
        if (customerLookup) {
          customerLookupFields.push(fieldName);
        }
        return s.f(fieldName, param.coereced);
      },
      field: param => {
        let fieldName = param.fieldName;
        metadataFields.push(fieldName);
        return s.f(fieldName, param.coereced);
      }
    });
  });
  if (customerLookupFields.length === 0) {
    Stdlib_Exn.raiseError("The data schema must define at least one primary field with ~customerLookup=true");
  }
  let dict = S$RescriptSchema.reverseConvertOrThrow(data, schema);
  let customerMetadata = {};
  customerLookupFields.forEach(name => {
    customerMetadata[name] = dict[name];
  });
  return {
    value: data,
    dict: dict,
    schema: schema,
    primaryFields: primaryFields,
    customerMetadata: customerMetadata,
    metadataFields: metadataFields
  };
}

async function internalRetrieveSubscription(stripe, data, config, customerId, usedMetersAcc) {
  console.log("Searching for an existing \"" + config.ref + "\" subscription for customer \"" + customerId + "\"...");
  let subscriptions = await listSubscriptions(stripe, config, customerId);
  console.log("Found " + subscriptions.length.toString() + " subscriptions for the customer. Validating that the new subscription is not already active...");
  return Primitive_option.fromUndefined(subscriptions.find(subscription => {
    if (usedMetersAcc !== undefined) {
      let usedMetersAcc$1 = Primitive_option.valFromOption(usedMetersAcc);
      Belt_Array.forEach(subscription.items.data, item => {
        let meterEventName = Js_dict.get(item.price.metadata, "#meter_event_name");
        if (meterEventName !== undefined) {
          usedMetersAcc$1.add(meterEventName);
          return;
        }
        
      });
    }
    if (data.primaryFields.every(name => subscription.metadata[name] === data.dict[name])) {
      console.log("Found an existing subscription. Subscription ID: " + subscription.id);
      return true;
    } else {
      return false;
    }
  }));
}

function retrieveCustomer(stripe, config, data) {
  return findByMetadata(stripe, processData(data, config).customerMetadata);
}

async function retrieveSubscriptionWithCustomer(stripe, config, data) {
  let processedData = processData(data, config);
  let customer = await findByMetadata(stripe, processedData.customerMetadata);
  if (customer === undefined) {
    return {
      customer: undefined,
      subscription: undefined
    };
  }
  let subscription = await internalRetrieveSubscription(stripe, processedData, config, customer.id, undefined);
  if (subscription !== undefined) {
    return {
      customer: customer,
      subscription: subscription
    };
  } else {
    return {
      customer: customer,
      subscription: undefined
    };
  }
}

async function retrieveSubscription(stripe, config, data) {
  return (await retrieveSubscriptionWithCustomer(stripe, config, data)).subscription;
}

async function createHostedCheckoutSession(stripe, params) {
  let data = processData(params.data, params.config);
  let planMetadataFields = [planField];
  let planSchema = S$RescriptSchema.union(params.config.plans.map(param => {
    let planConfig = param[1];
    let planRef = param[0];
    return S$RescriptSchema.object(s => {
      let matchesCounter = {
        contents: -1
      };
      s.tag(planField, planRef);
      return planConfig({
        field: param => {
          let fieldName = param.fieldName;
          planMetadataFields.push(fieldName);
          return s.f(fieldName, param.coereced);
        },
        tag: (param, value) => {
          let fieldName = param.fieldName;
          planMetadataFields.push(fieldName);
          s.f(fieldName, S$RescriptSchema.coerce(param.coereced, S$RescriptSchema.literal(value)));
        },
        matches: schema => {
          matchesCounter.contents = matchesCounter.contents + 1 | 0;
          return s.f("#matches" + matchesCounter.contents.toString(), schema);
        }
      });
    });
  }));
  let rawTier = S$RescriptSchema.reverseConvertOrThrow(params.plan, planSchema);
  let planId = rawTier[planField];
  let p = params.config.products(params.plan, params.data);
  let products = p.length !== 0 ? p : Stdlib_Exn.raiseError("Tier \"" + planId + "\" doesn't have any products configured");
  let c = await findByMetadata(stripe, data.customerMetadata);
  let customer;
  if (c !== undefined) {
    customer = c;
  } else {
    console.log("Creating a new customer...");
    let c$1 = await stripe.customers.create({
      metadata: data.customerMetadata
    });
    console.log("Successfully created a new customer with id: " + c$1.id);
    customer = c$1;
  }
  let usedCustomerMeters = new Set();
  let subscription = await internalRetrieveSubscription(stripe, data, params.config, customer.id, Primitive_option.some(usedCustomerMeters));
  if (subscription !== undefined) {
    Stdlib_Exn.raiseError("There's already an active \"" + params.config.ref + "\" subscription for " + data.primaryFields.map(name => name + "=" + data.dict[name]).join(", ") + " with the \"" + subscription.metadata[planField] + "\" plan and id \"" + subscription.id + "\". Either update the existing subscription or cancel it and create a new one");
  } else {
    console.log("Customer doesn't have an active \"" + params.config.ref + "\" subscription");
  }
  let productItems = await sync(stripe, {
    products: products
  }, Primitive_option.some(usedCustomerMeters), params.interval);
  console.log("Creating a new checkout session for subscription \"" + params.config.ref + "\" plan \"" + planId + "\"...");
  let match = params.config.termsOfServiceConsent;
  let session = await stripe.checkout.sessions.create({
    mode: "subscription",
    success_url: params.successUrl,
    cancel_url: params.cancelUrl,
    consent_collection: match !== undefined && match ? ({
        terms_of_service: "required"
      }) : undefined,
    subscription_data: {
      description: params.description,
      metadata: Js_dict.fromArray(data.metadataFields.map(name => [
        name,
        data.dict[name]
      ]).concat(planMetadataFields.map(name => [
        name,
        rawTier[name]
      ]))),
      billing_cycle_anchor: params.billingCycleAnchor
    },
    allow_promotion_codes: params.allowPromotionCodes,
    customer: customer.id,
    line_items: productItems.map(param => {
      let prices = param.prices;
      let product = param.product;
      let match = params.interval;
      let len = prices.length;
      let lineItemPrice = len !== 1 ? (
          len !== 0 ? (
              match !== undefined ? Stdlib_Exn.raiseError("Product \"" + product.name + "\" has multiple prices for interval \"" + match + "\"") : Stdlib_Exn.raiseError("Product \"" + product.name + "\" has multiple prices but no interval specified. Use \"interval\" param to dynamically choose which price use for the plan")
            ) : (
              match !== undefined ? Stdlib_Exn.raiseError("Product \"" + product.name + "\" doesn't have prices for interval \"" + match + "\"") : Stdlib_Exn.raiseError("Product \"" + product.name + "\" doesn't have any prices")
            )
        ) : prices[0];
      let match$1 = lineItemPrice.recurring;
      let id = lineItemPrice.id;
      if (match$1 === null) {
        return {
          price: id,
          quantity: 1
        };
      }
      let tmp = match$1.meter;
      if (tmp === null) {
        return {
          price: id,
          quantity: 1
        };
      } else {
        return {
          price: id
        };
      }
    })
  });
  let url = session.url;
  let tmp;
  tmp = url === null ? "" : " Url: " + url;
  console.log("Successfully created a new checkout session. Session ID: " + session.id + "." + tmp + "\n    ");
  return session;
}

function verify(subscription, config) {
  if (subscription.metadata[refField] === config.ref) {
    return subscription;
  }
  
}

let Billing = {
  Plan: Plan,
  refField: refField,
  planField: planField,
  listSubscriptions: listSubscriptions,
  retrieveCustomer: retrieveCustomer,
  retrieveSubscriptionWithCustomer: retrieveSubscriptionWithCustomer,
  retrieveSubscription: retrieveSubscription,
  createHostedCheckoutSession: createHostedCheckoutSession,
  verify: verify
};

function ref(fieldName, schema) {
  return {
    fieldName: fieldName,
    schema: schema,
    coereced: S$RescriptSchema.coerce(S$RescriptSchema.string, schema)
  };
}

function get(subscription, metadataRef) {
  return S$RescriptSchema.parseOrThrow(subscription.metadata[metadataRef.fieldName], metadataRef.schema);
}

let Metadata = {
  ref: ref,
  get: get
};

export {
  Stdlib,
  make,
  Meter,
  MeterEvent,
  Price,
  Product,
  ProductCatalog,
  Customer,
  Subscription,
  CustomerPortal,
  Checkout,
  Webhook,
  Billing,
  Metadata,
}
/* stripe Not a pure module */
