// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import Stripe from "stripe";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as S$RescriptSchema from "rescript-schema/src/S.res.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function $$catch(promise, callback) {
  return promise.catch(function (err) {
              return callback(Caml_js_exceptions.internalToOCamlException(err));
            });
}

var $$Promise = {
  $$catch: $$catch
};

var unsafeDeleteKey = (function (dict,key) {
      delete dict[key];
    });

var Dict = {
  unsafeDeleteKey: unsafeDeleteKey
};

var Stdlib = {
  $$Promise: $$Promise,
  Dict: Dict
};

function make(prim) {
  return new Stripe(prim);
}

var Meter = {};

var Price = {};

var Product = {};

async function syncProduct(stripe, productConfig, meters) {
  var unsyncedPriceConfigs = {};
  for(var idx = 0 ,idx_finish = productConfig.prices.length; idx < idx_finish; ++idx){
    var priceConfig = productConfig.prices[idx];
    unsyncedPriceConfigs[priceConfig.lookupKey] = priceConfig;
    var match = priceConfig.recurring;
    if (match.TAG === "Metered") {
      if (meters !== undefined) {
        
      } else {
        Js_exn.raiseError("Product \"" + productConfig.name + "\" has a mettered price. It's required to provide a map of metters to perform the sync");
      }
    }
    
  }
  if (Object.keys(unsyncedPriceConfigs).length !== productConfig.prices.length) {
    Js_exn.raiseError("Product '" + productConfig.name + "' has price configurations with duplicated lookup keys. It's allowed to have only unique lookup keys.");
  }
  console.log("Searching for active product \"" + productConfig.lookupKey + "\"...");
  var match$1 = await stripe.products.search({
        query: "active:\"true\" AND metadata[\"lookup_key\"]:\"" + productConfig.lookupKey + "\"",
        limit: 2
      });
  var match$2 = match$1.data;
  var len = match$2.length;
  var product;
  if (len !== 1) {
    if (len !== 0) {
      product = Js_exn.raiseError("There are multiple active products \"" + productConfig.lookupKey + "\". Please go to dashboard and delete not needed ones (https://dashboard.stripe.com/test/products?active=true)");
    } else {
      console.log("No active product \"" + productConfig.lookupKey + "\" found. Creating a new one...");
      var p = await stripe.products.create({
            name: productConfig.name,
            metadata: Js_dict.fromArray([[
                    "lookup_key",
                    productConfig.lookupKey
                  ]]),
            unit_label: productConfig.unitLabel
          });
      console.log("Product \"" + productConfig.lookupKey + "\" successfully created. Product ID: " + p.id);
      product = p;
    }
  } else {
    var p$1 = match$2[0];
    console.log("Found an existing product \"" + productConfig.lookupKey + "\". Product ID: " + p$1.id);
    var fieldsToSync = {};
    var match$3 = p$1.unit_label;
    var match$4 = productConfig.unitLabel;
    var exit = 0;
    if (match$3 === null) {
      if (match$4 !== undefined) {
        exit = 1;
      }
      
    } else if (!(match$4 !== undefined && match$3 === match$4)) {
      exit = 1;
    }
    if (exit === 1) {
      if (match$4 !== undefined) {
        fieldsToSync.unit_label = match$4;
      } else {
        fieldsToSync.unit_label = "";
      }
    }
    var fieldNamesToSync = Object.keys(fieldsToSync);
    if (fieldNamesToSync.length > 0) {
      console.log("Syncing product \"" + productConfig.lookupKey + "\" fields " + fieldNamesToSync.join(", ") + "...");
      var p$2 = await stripe.products.update(p$1.id, fieldsToSync);
      console.log("Product \"" + productConfig.lookupKey + "\" fields successfully updated");
      product = p$2;
    } else {
      console.log("Product \"" + productConfig.lookupKey + "\" is in sync");
      product = p$1;
    }
  }
  console.log("Searching for product \"" + productConfig.lookupKey + "\" active prices...");
  var prices = await stripe.prices.list({
        active: true,
        product: product.id
      });
  console.log("Found " + prices.data.length.toString() + " product \"" + productConfig.lookupKey + "\" active prices");
  if (prices.has_more) {
    Js_exn.raiseError("The pagination on prices is not supported yet. Product \"" + productConfig.lookupKey + "\" has to many active prices");
  }
  var createPriceFromConfig = async function (priceConfig, transferLookupKey) {
    var match = priceConfig.recurring;
    var tmp;
    if (match.TAG === "Metered") {
      var meter = Js_dict.get(Belt_Option.getExn(meters), priceConfig.lookupKey);
      var meter$1;
      if (meter !== undefined) {
        meter$1 = meter;
      } else {
        console.log("Meter \"" + priceConfig.lookupKey + "\" does not exist. Creating...");
        var meter$2 = await stripe.billing.meters.create({
              default_aggregation: {
                formula: "sum"
              },
              display_name: priceConfig.lookupKey,
              event_name: priceConfig.lookupKey
            });
        console.log("Meter \"" + priceConfig.lookupKey + "\" successfully created. Meter ID: " + meter$2.id);
        meter$1 = meter$2;
      }
      tmp = {
        interval: match.interval,
        meter: meter$1.id,
        usage_type: "metered"
      };
    } else {
      tmp = {
        interval: match.interval
      };
    }
    return await stripe.prices.create({
                currency: priceConfig.currency,
                product: product.id,
                recurring: tmp,
                unit_amount: priceConfig.unitAmountInCents,
                lookup_key: priceConfig.lookupKey,
                transfer_lookup_key: transferLookupKey
              });
  };
  var priceUpdatePromises = prices.data.map(async function (price) {
        var lookupKey = price.lookup_key;
        var maybePriceConfig;
        maybePriceConfig = lookupKey === null ? undefined : Js_dict.get(unsyncedPriceConfigs, lookupKey);
        if (maybePriceConfig !== undefined) {
          unsafeDeleteKey(unsyncedPriceConfigs, maybePriceConfig.lookupKey);
          console.log("Found an existing price \"" + maybePriceConfig.lookupKey + "\". Price ID: " + price.id);
          var isPriceInSync = false;
          if (maybePriceConfig.currency === price.currency && maybePriceConfig.unitAmountInCents === price.unit_amount) {
            var priceRecurring = price.recurring;
            var tmp;
            if (priceRecurring === null) {
              tmp = false;
            } else {
              var match = maybePriceConfig.recurring;
              tmp = match.TAG === "Metered" ? priceRecurring.usage_type === "metered" && priceRecurring.interval === match.interval && Caml_option.null_to_opt(priceRecurring.meter) === Belt_Option.map(Js_dict.get(Belt_Option.getExn(meters), maybePriceConfig.lookupKey), (function (m) {
                        return m.id;
                      })) : priceRecurring.usage_type === "licensed" && priceRecurring.interval === match.interval && priceRecurring.meter === null;
            }
            isPriceInSync = tmp;
          }
          if (isPriceInSync) {
            console.log("Price \"" + maybePriceConfig.lookupKey + "\" is in sync");
            return price;
          }
          console.log("Price \"" + maybePriceConfig.lookupKey + "\" is not in sync. Updating...");
          var match$1 = await Promise.all([
                createPriceFromConfig(maybePriceConfig, true),
                stripe.prices.update(price.id, {
                      active: false
                    })
              ]);
          var newPrice = match$1[0];
          console.log("Price \"" + maybePriceConfig.lookupKey + "\" successfully recreated with the new values. New Price ID: " + newPrice.id + ". Old Price ID: " + price.id);
          return newPrice;
        }
        console.log("Price " + price.id + " with lookupKey " + price.lookup_key + " is not configured on product " + productConfig.lookupKey + ". Setting it to inactive...");
        await stripe.prices.update(price.id, {
              active: false
            });
        console.log("Price " + price.id + " successfully set to inactive");
      });
  var priceCreatePromises = Js_dict.values(unsyncedPriceConfigs).map(async function (priceConfig) {
        console.log("Price \"" + priceConfig.lookupKey + "\" is missing on product \"" + productConfig.lookupKey + "\"\". Creating it...");
        var price = await createPriceFromConfig(priceConfig, undefined);
        console.log("Price \"" + priceConfig.lookupKey + "\" successfully created. Price ID: " + price.id);
        return price;
      });
  var prices$1 = Belt_Array.keepMap(await Promise.all(priceUpdatePromises.concat(priceCreatePromises)), (function (p) {
          return p;
        }));
  return {
          product: product,
          prices: prices$1
        };
}

async function sync(stripe, productCatalog) {
  var isMeterNeeded = productCatalog.products.some(function (p) {
        return p.prices.some(function (p) {
                    var match = p.recurring;
                    if (match.TAG === "Metered") {
                      return true;
                    } else {
                      return false;
                    }
                  });
      });
  var meters;
  if (isMeterNeeded) {
    console.log("Loading active meters...");
    var match = await stripe.billing.meters.list({
          status: "active",
          limit: 100
        });
    var meters$1 = match.data;
    console.log("Loaded " + meters$1.length.toString() + " active meters");
    meters = Js_dict.fromArray(meters$1.map(function (meter) {
              return [
                      meter.event_name,
                      meter
                    ];
            }));
  } else {
    meters = undefined;
  }
  var products = await Promise.all(productCatalog.products.map(function (p) {
            return syncProduct(stripe, p, meters);
          }));
  console.log("Successfully finished syncing products");
  return products;
}

var ProductCatalog = {
  syncProduct: syncProduct,
  sync: sync
};

var Customer = {};

function isTerminatedStatus(status) {
  return false;
}

var Subscription = {
  isTerminatedStatus: isTerminatedStatus
};

var Session = {};

var Checkout = {
  Session: Session
};

var Tier = {};

var idField = "subscription_id";

var tierField = "subscription_tier";

function validateMetadataSchema(schema) {
  var match = schema.t;
  if (typeof match !== "object") {
    if (match === "string") {
      return ;
    } else {
      return Js_exn.raiseError("Currently only string schemas are supported for data fields");
    }
  } else if (match.TAG === "literal" && match._0.kind === "String") {
    return ;
  } else {
    return Js_exn.raiseError("Currently only string schemas are supported for data fields");
  }
}

async function createHostedCheckoutSession(stripe, params) {
  var primaryFields = [idField];
  var customerLookupFields = [];
  var dataMetadataFields = [idField];
  var tierMetadataFields = [tierField];
  var productsByTier = {};
  var dataSchema = S$RescriptSchema.object(function (s) {
        s.tag(idField, params.config.id);
        return params.config.data({
                    primary: (function (name, schema, customerLookupOpt) {
                        var customerLookup = customerLookupOpt !== undefined ? customerLookupOpt : false;
                        validateMetadataSchema(schema);
                        primaryFields.push(name);
                        dataMetadataFields.push(name);
                        if (customerLookup) {
                          customerLookupFields.push(name);
                        }
                        return s.f(name, schema);
                      }),
                    metadata: (function (name, schema) {
                        validateMetadataSchema(schema);
                        dataMetadataFields.push(name);
                        return s.f(name, schema);
                      })
                  });
      });
  var tierSchema = S$RescriptSchema.union(params.config.tiers.map(function (param) {
            var tierConfig = param[1];
            var id = param[0];
            return S$RescriptSchema.object(function (s) {
                        var products = [];
                        var tier = tierConfig({
                              metadata: (function (name, schema) {
                                  validateMetadataSchema(schema);
                                  tierMetadataFields.push(name);
                                  return s.f(name, schema);
                                }),
                              interval: (function () {
                                  return s.f("~~interval", S$RescriptSchema.$$enum([
                                                  "day",
                                                  "week",
                                                  "month",
                                                  "year"
                                                ]));
                                }),
                              product: (function (productConfig) {
                                  products.push(productConfig);
                                })
                            });
                        s.tag(tierField, id);
                        productsByTier[id] = products;
                        return tier;
                      });
          }));
  if (customerLookupFields.length === 0) {
    Js_exn.raiseError("The data schema must define at least one primary field with ~customerLookup=true");
  }
  var rawData = S$RescriptSchema.reverseConvertOrThrow(params.data, dataSchema);
  var rawTier = S$RescriptSchema.reverseConvertOrThrow(params.tier, tierSchema);
  var tierId = rawTier[tierField];
  var p = Js_dict.get(productsByTier, tierId);
  var products = p !== undefined ? (
      p.length !== 0 ? p : Js_exn.raiseError("Tier \"" + tierId + "\" doesn't have any products configured")
    ) : Js_exn.raiseError("Tier \"" + tierId + "\" is not configured on the subscription plan");
  var specificInterval = rawTier["~~interval"];
  var customerSearchQuery = customerLookupFields.map(function (name) {
          return "metadata[\"" + name + "\"]:\"" + rawData[name] + "\"";
        }).join("AND");
  console.log("Searching for an existing customer with query: " + customerSearchQuery);
  var match = await stripe.customers.search({
        query: customerSearchQuery,
        limit: 2
      });
  var match$1 = match.data;
  var len = match$1.length;
  var customer;
  if (len !== 1) {
    if (len !== 0) {
      customer = Js_exn.raiseError("Found multiple customers for the search query: " + customerSearchQuery);
    } else {
      console.log("No customer found. Creating a new one...");
      var c = await stripe.customers.create({
            metadata: Js_dict.fromArray(customerLookupFields.map(function (name) {
                      return [
                              name,
                              rawData[name]
                            ];
                    }))
          });
      console.log("Successfully created a new customer with id: " + c.id);
      customer = c;
    }
  } else {
    var c$1 = match$1[0];
    console.log("Successfully found customer with id: " + c$1.id);
    customer = c$1;
  }
  console.log("Searching for an existing \"" + params.config.id + "\" subscription...");
  var match$2 = await stripe.subscriptions.list({
        customer: customer.id,
        status: "active",
        limit: 100
      });
  if (match$2.has_more) {
    Js_exn.raiseError("Customers has more than 100 subscriptions, which is not supported yet");
  } else {
    var subscriptions = match$2.data;
    console.log("Found " + subscriptions.length.toString() + " subscriptions for the customer. Validating that the new subscription is not already active...");
    var maybeExistingSubscription = subscriptions.find(function (subscription) {
          if (primaryFields.every(function (name) {
                  return subscription.metadata[name] === rawData[name];
                })) {
            console.log("Found an existing subscription. Subscription ID: " + subscription.id);
            return true;
          } else {
            return false;
          }
        });
    if (maybeExistingSubscription !== undefined) {
      Js_exn.raiseError("There's already an active \"" + maybeExistingSubscription.id + "\" subscription for " + primaryFields.map(function (name) {
                  return name + "=" + rawData[name];
                }).join(", ") + " with the \"" + tierId + "\" tier. Either update the existing subscription or cancel it and create a new one");
    } else {
      console.log("Customer doesn't have an active \"" + params.config.id + "\" subscription");
    }
  }
  var productItems = await sync(stripe, {
        products: products
      });
  console.log("Creating a new checkout session for subscription \"" + params.config.id + "\" tier \"" + tierId + "\"...");
  var match$3 = params.config.termsOfServiceConsent;
  var session = await stripe.checkout.sessions.create({
        mode: "subscription",
        success_url: params.successUrl,
        cancel_url: params.cancelUrl,
        consent_collection: match$3 !== undefined && match$3 ? ({
              terms_of_service: "required"
            }) : undefined,
        subscription_data: {
          description: params.description,
          metadata: Js_dict.fromArray(dataMetadataFields.map(function (name) {
                      return [
                              name,
                              rawData[name]
                            ];
                    }).concat(tierMetadataFields.map(function (name) {
                        return [
                                name,
                                rawTier[name]
                              ];
                      }))),
          billing_cycle_anchor: params.billingCycleAnchor
        },
        allow_promotion_codes: params.allowPromotionCodes,
        customer: customer.id,
        line_items: productItems.map(function (param) {
              var prices = param.prices;
              var product = param.product;
              var lineItemPrice;
              var exit = 0;
              var len = prices.length;
              if (len !== 1) {
                if (len !== 0) {
                  exit = 1;
                } else {
                  lineItemPrice = Js_exn.raiseError("Product \"" + product.name + "\" doesn't have any prices");
                }
              } else {
                var price = prices[0];
                if (specificInterval !== undefined) {
                  exit = 1;
                } else {
                  lineItemPrice = price;
                }
              }
              if (exit === 1) {
                if (specificInterval !== undefined) {
                  var p = Belt_Array.reduce(prices, undefined, (function (acc, price) {
                          var match = price.recurring;
                          var isValid;
                          isValid = match === null ? true : match.interval === specificInterval;
                          if (acc !== undefined) {
                            if (isValid) {
                              return Js_exn.raiseError("Product \"" + product.name + "\" has multiple prices for the \"" + specificInterval + "\" interval billing");
                            } else {
                              return acc;
                            }
                          } else if (isValid) {
                            return price;
                          } else {
                            return acc;
                          }
                        }));
                  lineItemPrice = p !== undefined ? p : Js_exn.raiseError("Product \"" + product.name + "\" doesn't have a price for the \"" + specificInterval + "\" interval billing");
                } else {
                  lineItemPrice = Js_exn.raiseError("Product \"" + product.name + "\" have multiple prices but no interval specified. Use \"s.interval\" to dynamically choose which price use for the tier");
                }
              }
              var match = lineItemPrice.recurring;
              var id = lineItemPrice.id;
              if (match === null) {
                return {
                        price: id,
                        quantity: 1
                      };
              }
              var tmp = match.meter;
              if (tmp === null) {
                return {
                        price: id,
                        quantity: 1
                      };
              } else {
                return {
                        price: id
                      };
              }
            })
      });
  console.log("Successfully created a new checkout session");
  console.log(session);
}

var TieredSubscription = {
  Tier: Tier,
  createHostedCheckoutSession: createHostedCheckoutSession
};

export {
  Stdlib ,
  make ,
  Meter ,
  Price ,
  Product ,
  ProductCatalog ,
  Customer ,
  Subscription ,
  Checkout ,
  TieredSubscription ,
}
/* stripe Not a pure module */
